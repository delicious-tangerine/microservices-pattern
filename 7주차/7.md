# 7. 마이크로서비스 쿼리 구현

- 마이크로서비스에서 쿼리 구현은 어떻게 할까?
- 여러 DB에 분산된 데이터를 조회해야 한다.
- API 조합 패턴
  - 서비스 클라이언트가 데이터를 가진 여러 서비스를 직접 호출하여 그 결과를 조합하는 패턴
- CQRS 패턴
  - 쿼리만 지원하는 하나 이상의 뷰 전용 DB를 유지하는 패턴
  - API 조합패턴보다 강력한 만큼 구현하기는 더 복잡하다.

# 7.1 API 조합 패턴 응용 쿼리

- 여러 서비스에 있는 데이터를 조회하는 쿼리 작업

## 7.1.1 findOrder() 쿼리

- 주문 상태 뷰에서 호출
- 주문 상태 뷰는 음식점 관점의 주문/지불 상태 정보, 배달원의 현재 위치, 배달 예상 시각 등 배달 상태 정보가 표시
- (287p. 그림 7-1) 여러 서비스의 분산된 데이터의 모습을 보여준다.

## 7.1.2 API 조합 패턴 개요

- API 조합기가 각 서비스를 쿼리하여 데이터를 조회 한다.
- (288p. 그림 7-2)
- 이 패턴으로 특정 쿼리 작업을 구현할 수 있을지 여부는 데이터가 어떻게 분할되었는지, 데이터를 가진 서비스가 어떤 API 기능을 표출하는지 등 다양한 요인에 따라 가변적이다.
- 애그리거트가 거대한 데이터 뭉치를 비효율적으로 인-메모리 조인을 해야 할 수도 있다.
- 대부분의 경우 이패턴으로 되긴 한다.

## 7.1.3 API 조합 패턴으로 findOrder() 쿼리 구현

- 단순히 기본키로 EQUI 조인 해서 쿼리하는 작업
- (289p. 그림 7-3)
- 간단해보이지만 설계 이슈가 있다.

## 7.1.4 API 조합 설계 이슈

- 어느 컴포넌트를 쿼리 작업의 API 조합기로 선정할 것인가?
  - API 조합기 역할을 누가 맡을지 결정 ...
  - 서비스 클라이언트를 API 조합기로 임명하는것.
  - 애플리케이션 외부 API가 구현된 API 게이트웨이를 API 조합기로 만드는것
  - 스탠드얼론 서비스로 구현하는것
- 어떻게 해야 효율적으로 취합 로직을 작성할 것인가?
- API 조합기는 리액티브 프로그래밍 모델을 사용해야 한다.
  - 지연시간 최소화 하는 전략
  - API 조합기에서 서비스를 병렬 호출해야 한다.
    - 의존 관계가 없는 서비스들은 병렬 호출 가능하지만 어떤 프로바이더 서비스를 호출하기 위해 다른 프로바이더 서비스의 결과를 먼저 가져와야 하는 경우도 있다. → 순차/병렬 서비스 호출이 뒤섞이면 너무 어려워! 리액티브 프로그래밍이 필요 하다.

## 7.1.5 API 조합 패턴의 장단점

- API 조합 패턴은 마이크로서비스 아키텍처에서 아주 쉽고 단순하게 쿼리 작업을 구현할 수 있게 해주지만, 다음과 같은 단점도 있다.
  - 오버헤드 증가 → 여러 서비스, DB 호출, 쿼리 하는 오버헤드 컴퓨팅/네트워크 리소스
  - 가용성 저하 우려
    - 가용성을 높이는 전략은 프로바이더가 불능일 경우 API 조합기가 이전에 캐시한 데이터를 반환하는 것
    - 미완성된 데이터를 반환하는것 → 주방 서비스가 일시 불능이면 그거 빼고는 나간다
  - 데이터 일관성 결여
    - 여러 서비스에서 바라보는 정보가 다를 수 있다.
    - 그럼에도 불구하고 쉽게 구현할 수 있어 유용하다.
    - 효율적으로 구현하기 어려운 쿼리는 CQRS를 사용하자!

# 7.2 CQRS 패턴

- CQRS 는 RDBMS 특유의 트랜잭션 기능과 텍스트 검색 DB의 탁월한 쿼리 능력을 융합하여 활용하는 종류의 아키텍처를 일반화한것.
- 하나 이상의 쿼리가 구현된 하나 이상의 뷰 DB를 유지하는 기법

## 7.2.1 CQRS의 필요성

- API 조합 패턴으로 구현하기 어려운 다중 서비스 쿼리가 있다.
- findOrderHisotry() 메소드의 예제
- 어려운 단일 서비스 쿼리: findAvailableRestaurants()

## 7.2.2 CQRS 개요

- API를 조합하여 여러 서비스에 흩어진 데이터를 조회하려면 값비싸고 비효율적인 인메모리 조인을 해야 한다.
- 데이터를 가진 서비스는 필요한 쿼리를 효율적으로 지원하지 않는 DB에, 또는 그런 형태로 데이터를 저장한다.
- 관심사를 분리할 필요가 있다는 것은 데이터를 가진 서비스가 쿼리 작업을 구현할 장소로 적합하지 않다는 뜻이다.
- CQRS는 커맨드와 쿼리를 서로 분리한다.
  - 조회 기능은 쿼리 쪽 모듈 및 데이터 모델에
  - 생성/수정/삭제 기능은 커맨드 쪽 모듈 및 데이터 모델에 구현 한다.
  - 양쪽 데이터 모델 사이의 동기화는 커맨드 쪽에서 발행한 이벤트를 쿼리 쪽에서 구독하는 식으로 이루어 진다.
  - (300p. 그림 7-8)
  - 쿼리 서비스는 여러 서비스가 발행한 이벤트를 구독하고 뷰 DB를 업데이트 한다.

## 7.2.3 CQRS의 장점

- 마이크로서비스 아키텍처에서 호율적인 쿼리가 가능하다.
- 다양한 쿼리를 효율적으로 구현할 수 있다.
- 이벤트 소싱 애플리케이션에서 쿼리가 가능하다.
- 관심사가 더 분리된다.

## 7.2.4 CQRS의 단점

- 아키텍처가 복잡하다.
- 복제 시차를 신경 써야 한다.

# 7.3 CQRS 뷰 설계

- CQRS 뷰 모듈에는 하나 이상의 쿼리 작업으로 구성된 API가 있다.
- (304p. 그림 7-10)

## 7.3.1 뷰 DB 선택

- SQL vs NoSQL DB

## 7.3.2 데이터 접근 모듈 설계

- 동시성 처리
  - 동일한 DB 레코드에 대해 DAO가 여러 동시 업데이트를 처리하는 경우가 있다. 뷰가 한 종류의 애그리거트가 발행한 이벤트를 구독한다면 동시성 이슈는 없다. 하지만 여러 애그리거트를 구독할 경우...
  - 동시성 처리를 위해 락을 사용해야 한다.
- 멱등한 이벤트 핸들러
- 클라이언트 애플리케이션이 최종 일관된 뷰를 사용할 수 있다.

## 7.3.3 CQRS 뷰 추가 및 업데이트

- 새 쿼리를 지원하기 위해 새 뷰를 추가해야 할 때도 있고, 버그 조치를 위해 재생성해야 할 경우도 있을것이다.
- 말처럼 쉬운게 아니다!
  - 아카이빙된 이벤트를 이용하여 CQRS 뷰 구축 → 이미 사라진 이벤트 처리
  - CQRS 뷰를 단계적으로 구축 → 너무 많아지면 언젠가 느려짐, 비용도 커짐 → 2단계 증분 알고리즘 사용

# 7.4 CQRS 뷰 구현: AWS DynamoDB 응용

- 데이터 모델링 및 쿼리 설계
- 쿼리 전용 인덱스 정의
- ...
