# 13. 마이크로서비스로 리팩터링

- 처음부터 다 뜯어 고치기 어렵다면 스트랭글러 애플리케이션을 개발해서 단계적으로 모놀리식을 마이크로서비스로 전환 하자.

# 13.1 마이크로서비스 리팩터링 개요

- 모놀리스를 마이크로서비스를 단계적으로 리팩터링하는 전략
- 비즈니스를 지원하기 위해 개선 사항을 조기에, 자주 전달하는 것이 왜 중요한지
- 소수의 서비스 개발이 완료 되기 전에는 정교한 배포 인프라에투자하는 일을 삼가야 하는 이유

## 13.1.1 모놀리스를 왜 리팩터링 하는가?

- 모놀리식 지옥에 빠진 상황이라면?
  - 느린 전달
  - 버그 투성이 소프트웨어 릴리즈 (feat. 테스트성의 결여)
  - 나쁜 확장성

## 13.1.2 모놀리스 옥죄기

- 완전히 뜯어고치기를 삼가하라 - 실패할 가능성이 많다.
  - 리스크가 큼
  - 신규 프로젝트 & 레거시 동시 보수 하다가 이도저도 못함
- (537p. 그림 13-1)
- 값을 조기에 자주 검증
  - 마이크로 서비스로 전환을 하면서 여러가지 효과(전달 속도가 빨라짐 등 ...)를 바로바로 볼 수 있다.
- 기술 배포 인프라: 모든 것이 다 필요한 것은 아니다
  - 반드시 있어야 할 것은 테스트 자동화 배포 파이프라인이 유일 하다.
  - 처음부터 정교한 인프라는 필요 없다. 처음엔 구성 파일을 하드코딩 해서 사용해도 충분.
  - 해보고 나서 다른걸 도입해도 늦지 않다.

# 13.2 모놀리스 → 마이크로서비스 리팩터링 전략

## 13.2.1 새 기능을 서비스로 구현한다.

- 이미 거대하고 복잡해진 모놀리식 애플리케이션에 새 기능이 구현된 코드는 더이상 추가하지 말라.
- 그럴수록 모놀리스는 더 비대해지고 관리하기 어려워진다.
- 새 서비스를 모놀리스에 연계
  - API 게이트웨이
  - 통합 글루 코드
- 하지만 모든 새 기능을 서비스로 구현할 수 있는 것은 아니다.
  - 진짜 별거 아닌 기능이라던지
  - 새 기능이 기존 모놀리스 코드에 너무 단단히 매여 있는 경우도 그러하다.

## 13.2.2 표현 계층과 백엔드를 분리한다.

- 표현계층을 비즈니스 로직과 데이터 접근 계층에서 분리하면 애플리케이션의 덩치를 줄일 수 있다.

## 13.2.3 기능을 여러 서비스로 추출한다.

- 도메인 모델 분리
- DB 리팩터링
- 변경 범위를 줄이기 위해 데이터를 복제

# 13.3 서비스와 모놀리스간 협동 설계

## 13.3.1 통합 글루 설계

- 서비스와 모놀리스를 협동할 수 있게 해주는 코드
- IPC를 이용하는 코드를 서비스 및 모놀리스 양쪽에 구성한다.
