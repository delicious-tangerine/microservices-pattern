# 8. 외부 API 패턴

- 애플리케이션의 외부 API는 클라이언트 종류가 다양한 만큼 설계하기가 어렵다.
- 만능 API 같은 것은 없다.

# 8.1 외부 API 설계 이슈

- 웹 애플리케이션은 방화벽 내부에서 실행되기 때문에 LAN을 통해 서비스에 접속하지만, 방화벽 외부의 다른 클라이언트는 인터넷을 통해 접근 한다.
- (325p. 그림 8-1)

## 8.1.1 API 설계 이슈

- 모놀리식 버전에서는 주문 내역을 반환하는 API가 있어서 모바일 클라이언트가 원하는 정보를 요청 한 번으로 모두 가져올 수 있지만, 마이크로서비스 버전은 주문 데이터가 여러 서비스에 분산되어 있다. 모바일 클라이언트가 서비스를 직접 호출하는 구조라면 서비스를 여러 번 호출해서 데이터를 가져올 수밖에 없다.
- (327p. 그림 8-2)
  - 클라이언트가 요청을 여러 번 전송하기 때문에 UX가 나빠진다. - 일반적으로 모바일 네트워크의 지연시간이 LAN보다 100배는 더 길다...(대박)
  - 캡슐화가 되지 않아 프런트엔드 개발자가 백엔드와 맞물려 코드를 변경해야 한다.
  - 클라이언트에 비친화적인 IPC를 사용 중인 클라이언트도 있다. - gRPC, AMQP 등..

## 8.1.2 API 설계 이슈: 다른 종류의 클라이언트

- 웹 애플리케이션
- 브라우저 기반의 자바스크립트 애플리케이션
- 서드파티 애플리케이션

# 8.2 API 게이트웨이 패턴

- 클라이언트가 인터넷을 통해서 API를 조합한다는 것은 실용적인 발상은 아니다.
- 캡슐화가 안 되므로 개발자가 서비스를 분해하고 API를 변경하기도 어렵다.

## 8.2.1 API 게이트웨이 패턴 개요

- API 게이트웨이는 방화벽 외부의 클라이언트가 애플리케이션에 API 요청을 하는 단일 창구 역할을 하는 서비스다. - 파사드 패턴을 떠올리면 된다.
- (331p. 그림 8-3)
- 요청 라우팅
- API 조합 (333p. 그림 8-4)
- 프로토콜 변환
  - 애플리케이션 내부에서 REST와 gRPC를 혼용할 경우도 외부 클라이언트에는 REST API 제공
- API 게이트웨이는 클라이언트마다 적합한 API를 제공 한다.
- 엣지 기능
  - 인증, 인가, 사용량 제한, 캐싱, 지표수집 등...
- API 게이트웨이 아키텍처
- API 게이트웨이 소유권 모델
  - 게이트웨이를 누가 관리?
- 프런트엔드 패턴을 위한 백엔드
  - 책임의 소재? 누가 잘못 커밋하면 어 떡 함 ! → 아예 클라이언트마다 API 게이트웨이를 따로 둔다...

## 8.2.2 API 게이트웨이의 장단점

- 장점
  - 애플리케이션 내부 구조를 캡슐화 한다.
  - 클라이언트 - 애플리케이션 간 왕복 횟수도 줄고 클라이언트 코드도 단순해진다.
- 단점
  - 개발, 배포, 관리 해야하는 컴포넌트가 하나 더 늘었다.

## 8.2.3. API 게이트웨이 사례: 넷플릭스

- 처음엔 만능 API로 개발 하려 했으나 안 된다는 사실을 깨닫고 기기별 API가 따로 구현된 게이트웨이가 있고, 각 클라이언트 팀이 소유/개발 한다.

## 8.2.4 API 게이트웨이 설계 이슈

- 성능과 확장성
  - 동기 I/O ? 비동기 I/O?
  - NIO 라고 다 빠른게 아니다. I/O 집약적 로직 vs CPU 집약적 로직
- 리액티브 프로그래밍 추상체를 이용하여 관리 가능한 코드 작성
  - 블로킹 방식 코드 예제 ⇒ 각 서비스 응답 시간 합한 만큼 기다려야 한다.
- 부분 실패 처리
  - 로드밸런서 뒤에 여러 API 게이트웨이

# 8.3 API 게이트웨이 구현

- 지금까지 배운 API 게이트웨이의 역할을 정리하면
  - 요청 라우팅
  - API 조합
  - 엣지 기능
  - 프로토콜 변환
- 두 가지 방법으로 구현 가능하다.
  - 기성 서비스를 활용
  - 직접 개발

## 갑분 GraphQL?
