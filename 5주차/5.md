# 5. 비즈니스 로직 설계

- 엔터프라이즈 애플리케이션의 핵심은 업무 규칙이 구현된 비즈니스 로직이다.
- 비지니스 로직이 여러 서비스에 흩어져 있는 마이크로서비스 아키텍처는 복잡한 비즈니스 로직을 개발하기가 까다롭다.
  - 도메인 모델은 대부분 상호 연관된 클래스가 거미줄처럼 뒤얽혀 있다.
  - 마이크로서비스 아키텍처 특유의 트랜잭션 관리 제약 조건하에서도 작동되는 비즈니스 로직을 설계해야 한다.
  - 이 두 문제는 DDD 애그리거트 패턴으로 해결할 수 있다.

# 5.1 비즈니스 로직 구성 패턴

- 육각형 아키텍처 구조의 주문 서비스 (198p 그림 5-1)
- 엔터프라이즈 애플리케이션 대부분은 객체 지향 언어로 개발하므로 클래스 및 메서드로 구성되지만, 객체 지향 언어를 써서 개발했다고 비즈니스 로직까지 저절로 객체 지향적으로 설계되는것은 아니다.
- 비즈니스 로직을 객체 지향적 방식으로 개발할 것인가, 절차적인 방식으로 개발할 것인가 하는 문제는 매우 중요한 의사 결정 항목이다.

## 5.1.1 비즈니스 로직 설계: 트랜잭션 스크립트 패턴

- 객제지향이 지나치다 싶으면 트랜잭션 스크립트 패턴을 적용하여 절차적인 코드를 작성하는 것이 더 합리적이다.

```java
class Order {
    private Long orderNo;
    private String menu;
}

class OrderService {

    Order createOrder() {
        Order order = new Order();
        order.orderNo = 1;
        order.menu = "떡보끼";
        return order;
    }

    Order reviseOrder() {
        ...
    }
}
```

```java
class OrderService {
    Order cancel(Order order) {
        Menu menu = menuService.getById(order.menu.id);
        menuService.addInventory(menu);
				order.cancel();
    }
}
```

## 5.1.2 비즈니스 로직 설계: 도메인 모델 패턴

- 절차적 접근 방식은 클래스를 어떻게 구성할지 고민하지 않고 단순하게 코딩할 수 있는 매력이 있지만, 비즈니스 로직이 복잡해지면 거의 관리 불가한 상태로 악화된다.
- 상태/동작을 모두 가진 클래스들이 생긴다.
- 객체지향 설계를 하면 좋은 점이 많다. 설계를 이해/관리 하기 쉽다.

```java
class Order {
    private Long orderNo;
    private String menu;

    public static Order create() {
         Order order = new Order();
        order.orderNo = 1;
        order.menu = "떡보끼";
        return order;
    }
    ..
}

class OrderService {

    Order createOrder() {
       return Order.create();
    }

    Order reviseOrder(Order order) {
       return order.revise();
    }
}
```

```java
class OrderService {
    Order cancel(Order order) {
        order.cancel();
    }
}

class Order() {
   private Menu menu;

   void cancel() {
      menu.addInventory();
      ...
   }
}

class Menu() {
   ...
}
```

## 5.1.3 도메인 주도 설계 개요

- DDD는 복잡한 비즈니스 로직을 개발하기 위해 OOD를 개선한 접근 방식이다. - 에릭 에반스
- DDD 설계는 각 서비스가 도메인 모델을 가지며, 애플리케이션 전체 도메인 모델의 문제점을 방지한다.
- DDD 빌딩 블록
  - 엔터티 (Jpa Entity, Django Model)
  - 값객체
  - 팩토리
  - 리포지터리
  - 서비스
  - 애그리거트!

# 5.2 도메인 모델 설계: DDD 애그리거트 패턴

- (202p 그림 5-4) 전통적인 복잡한 도메인 모델, 경계가 불분명 하다.

## 5.2.1 불분명한 경계 문제

## 5.2.2 애그리거트는 경계가 분명하다

- 하나의 루트 엔터티와 하나 이상의 기타 엔터티 + 밸류 객체로 구성된다.
- 비즈니스 객체는 대부분 애그리거트로 모델링 한다.
- 애그리거트는 일관된 경계
  - 항상 애그리거트 루트를 통해 호출된다.
  - 애그리거트 루트를 잠금 처리
- 애그리거트를 식별하는 일이 관건

## 5.2.3 애그리거트 규칙

- 루트만 참조하라
- 애그리거트 간 참조는 반드시 기본키를 사용하라 (반드시?)
  - 느슨한 경계, 실수로 다른 애그리거트를 업데이트 할 일이 벌어지지 않는다.
  - 하나의 트랜잭션으로 하나의 애그리거트를 생성/수정하라

## 5.2.4 애그리거트 입도

- 애그리거트의 크기를 결정 하는 일
- 애그리거트가 잘게 나뉘어 있으면 그만큼 동시 처리 가능한 요청 개수가 늘고 확장성이 좋아진다.
- 다른 한편으로 애그리거트는 곧 트랜잭션의 범위라서 어떤 업데이트를 원자적으로 처리하려면 크게 잡아야 할 수도 있다.

## 5.2.5 비즈니스 로직 설계: 애그리거트

- (210p 그림 5-9)

# 5.3 도메인 이벤트 발행

- 이벤트
  - 뭔가 일어난 것
  - 주목할 만한 사건
  - 사교적 행사나 활동
  - ...
- DDD 맥락에서 도메인 이벤트는 애그리거트에 발생한 사건
  - Order 애그리거트라면 주문 생성됨, 주문 취소됨, 주문 배달됨 등 상태가 바뀌는 이벤트가 발생

## 5.3.1 변경 이벤트를 발행하는 이유

- 다른 구성원들이 애그리거트의 상태 변경을 궁금해 하기 때문
- 다음과 같은 상황
  - 사가를 이용하여 여러 서비스에 걸쳐 데이터를 유지
  - 레플리카를 둔 서비스에 변경을 알림
  - 웹훅, 메시지 브로커 등을 통해 알림
  - etc...

## 5.3.2 도메인 이벤트란 무엇인가?

- 도메인 이벤트는 과거 분사형 동사로 명명한 클래스
  - OrderCreated
  - 감사 로그
  - 메타데이터는 엘벤로프 객체(이벤트를 감싼 객체)에 있다.

## 5.3.3 이벤트 강화

- 이벤트 컨슈머에서 직접 이벤트를 쿼리할수도 있지만 오버헤드를 유발 한다.
- 컨슈머에 필요한 정보를 이벤트가 갖고 다니는 이벤트 강화 기법을 적용 한다.
- 이벤트 강화 기법은 컨슈머를 단순화하는 이점이 있지만, 컨슈머 요건이 바뀌면 이벤트 클래스도 함께 바꾸어야 하므로 이벤트 클래스의 안정성은 떨어진다.

## 5.3.4 도메인 이벤트 식별

- X가 일어나면 Y를 수행하라.
- 이벤트 스토밍의 3단계
  - 이벤트 브레인스토밍
  - 이벤트 트리거 식별
  - 애그리거트 식별

## 5.3.5 도메인 이벤트 생성 및 발행

- 도메인 이벤트 생성
  - 개념적으로 도메인 이벤트는 애그리거트가 발행
  - 애그리거트가 메시징 API를 직접 호출하는 것도 가능하지만 디펜던시 주입을 할 수 없기 때문에 메시징 API를 메서드 인수르 전달해야 하는 문제가 있다. (에바다)
  - 애그리거트와 호출하는 서비스의 책임을 분리하자.
- 도메인 이벤트를 확실하게 발행하는 방법
  - 메시지를 로컬 DB 트랜잭션의 일부로 전달하는 방법은 3장에서 배웠다. 도메인 이벤트도 다를바 없다.
  - 트랜잭셔널 메시지 사용

## 5.3.6 도메인 이벤트 소비

# 5.4 주방 서비스 비즈니스 로직

# 5.5 주문 서비스 비즈니스 로직
