# 3. 프로세스 간 통신

# 마이크로서비스 아키텍처 IPC 개요

- 서비스에 적용 가능한 IPC 기술은 여러가지가 있다. HTTP 기반 REST, gRPC, AMQP, STOMP 등...

## 상호 작용 스타일

- 서비스간 IPC를 선택하기 전에 클라-서비스간 상호 작용 스타일을 잘 살펴보면 특정 기술의 세부 내용에 빠져 헤매는 일을 방지 할 수 있다.
  - 일대일 : 각 클라의 요청은 한 서비스가 처리
    - 요청/응답
    - 비동기 요청/응답
    - 단방향 알림
  - 일대다 : 각 클라의 요청을 여러 서비스가 협동하여 처리
    - 발행/구독
    - 발행/비동기 응답
  - 동기 : 클라는 서비스가 제시간에 응답하리라 기대하고 대기 도중 블로킹 가능
  - 비동기 : 클라이언트가 블로킹 하지 않음.

## 마이크로서비스 API 정의

- API와 인터페이스는 소프트웨어 개발의 핵심입니다. 애플리케이션은 여러 모듈로 구성되며, 각 모듈마다 자신의 클라이언트가 호출하는 작업이 정의된 인터페이스가 있습니다. 잘 설계된 인터페이스는 유용한 기능은 표출하되 그 구현체는 감추어져 있기 때문에 클라이언트에 영향을 미치지 않는 코드를 고칠 수 있습니다.
- TIP) 반드시 API를 먼저 설계하라

## API 발전시키기

- 시맨틱 버저닝
  - 버전 번호를 MAJOR, MINOR, PATCH 세 파트로 구성하고 규칙에 따라 증가 시킨다.
- 하위 호환되는 소규모 변경
  - 변경을 하더라도 가급적 하위 호환성을 보장하는 방향으로 해야 한다. 뭔가 API에 추가하는 변경은 대부분 하위 호환된다.
- 중대한 대규모 변경
  - REST API URL에 메이저 번호 표기
  - HTTP content negotiation을 이용

## 메세지 포맷

- 텍스트 메시지 포맷
  - JSON, XML 등
- 이진 메시지 포맷
  - 프로토콜 버퍼, 아브로 등

# 동기 RPI 패턴 응용 통신

## 동기 RPI 패턴: REST

- REST는 HTTP로 소통하는 IPC.
- HTTP 동사를 사용해 URL로 참조되는 리소스를 조작함. GET, POST, PUT . . .
- REST 성숙도 모델
  - HATEOAS - [https://joomn11.tistory.com/26](https://joomn11.tistory.com/26)
- 요청 한 번으로 많은 리소스를 가져오기 어렵다.
- 작업을 HTTP 동사에 매핑하기 어렵다.

## 동기 RPI 패턴: gRPC

- gRPC API는 프로토콜 버퍼 기반의 IDL로 정의하며, 프로토콜 버퍼 컴파일러로 클라이언트 쪽 스텁 및 서버 쪽 스켈레톤을 생성할 수 있다.
- 하나 이상의 서비스와 요청/응답 메시지 데피니션으로 구성 된다.

## 부분 실패 처리: 회로 차단기 패턴

- 분산 시스템은 서비스가 다른 서비스를 동기 호출할 때마다 부분 실패할 가능성이 존재 한다.
- 요청이 실패하거나 응답이 늦어지는 경우
- 무응답 서비스가 생기면 응답을 기다리며 무한정 블로킹할 것이고, 리소스가 고갈되어 결국 API 게이트웨이가 요청을 처리할 수 없게 된다.
- (119p 그림 3-2)
- 견고한 RPI 프록시 설계
  - 네트워크 타임아웃
  - 미처리 요청
  - 회로 차단기 패턴
- 불능 서비스 복구
  - fallback value
  - 모든 서비스의 데이터가 클라이언트에 똑같이 중요하지는 않다. 잘 판단해서 폴백.

## 서비스 디스커버리

- REST API를 호출할 때 이 서비스를 호출하는 코드는 서비스 인스턴스의 네트워크 위치를 알아야 한다.
- 물리적인 하드웨어를 기반으로 실행되는 애플리케이션은 대부분 정적이다.
- 클라우드 기반의 마이크로 서비스 애플리케이션은 네트워크 위치가 훨씬 동적이다.
  - 자동 확장, 실패, 업그레이드 등 여러가지 사유로 계속 달라짐
- 서비스 디스커버리 개요
  - 네트워크 위치를 DB화 한 서비스 레지스트리
  - 서비스 인스턴스가 시작/종료할 때마다 서비스 레지스트리가 업데이트 된다.
- 애플리케이션 수준의 서비스 디스커버리 패턴 적용
  - 애플리케이션 클라이언트가/서비스가 서비스 레지스트리와 직접 통신하는 방법
  - 서비스 레지스트리로부터 전체 서비스 인스턴스 목록을 가져와 요청을 라우팅 한다.
- 플랫폼에 내장된 서비스 디스커버리 패턴 적용
  - 도커나 쿠버네티스에 포함된 디스버커리 메커니즘
  - 요청하면 배포 플랫폼이 알아서 가용 서비스 인스턴스 중 하나로 요청을 라우팅 한다.
  - 서드파티 등록 패턴
  - 서버쪽 디스커버리 패턴

# 비동기 메시징 패턴 응용 통신

- 메시징은 서비스가 메시지를 서로 비동기적으로 주고받는 통신 방식이다.
- 보통 서비스간 중개 역할을 하는 브로커를 사용하지만 직접 통신하는 브로커리스 아키텍처도 있다.
- 비동기 통신을 하기 때문에 클라이언트가 응답을 기다리며 블로킹 하지 않는다.

## 메시징 개요

- 메시지는 메시지 채널을 통해 교환된다.
- 송신자가 채널에 메시지를 쓰면 수신자는 채널에서 메시지를 읽는다.

- 메시지
  - 메시지는 헤더와 본문으로 구성 된다.
  - 문서, 커맨드, 이벤트 같은 종류가 있다.
- 메시지 채널
  - (128p 그림 3-7)
  - 점대점, 발행-구독 채널 의 두 종류가 있다.

## 메시징 상호 작용 스타일 구현

- 요청/응답 및 비동기 요청/응답 (129p 그림 3-8)
- 단방향 알림
- 발행/구독
- 발행/비동기 응답

## 메시징 기반 서비스의 API 명세 작성

- 메시지 채널명, 메시지 타입과 포맷(JSON, XML, 프로토콜 버퍼 등) 명시
- 채널 및 메시지 타입은 자유롭게 기술

## 메시지 브로커

- 서비스가 서로 통신할 수 있게 해주는 인프라 서비스
- 브로커리스 메시징
  - 메시지를 서로 직접 교환
  - ZeroMQ
  - 브로커리스 메시징의 장단을 파악해보자
- 브로커 기반 메시징 개요
  - 송신자가 컨슈머의 네트워크 위치를 몰라도 된다는것이 가장 큰 장점!
- 메시지 브로커 메시지 채널 구현 (135p 표 3-2)
- 브로커 기반 메시징의 장단점
  - 장 - 느슨한 결합
  - 장 - 메시지 버퍼링
  - 장 - 유연한 통신
  - 장 - 명시적 IPC
  - 단 - 성능 병목 가능성
  - 단 - 단일 장애점 가능성
  - 단 - 운영 복잡도 증가

## 수신자 경합과 메시지 순서 유지

- 카프카, 키네시스 등은 샤딩된 채널을 이용
- (137p 그림 3-11)

## 중복 메시지 처리

- 멱등한 메시지 핸들러 작성
- 메시지 추적과 중복 메시지 솎아내기

## 트랜잭셔널 메시징

- DB 업데이트와 메시지 전송을 한 트랜잭션으로 묶어야 좋다
- DB 테이블을 메시지 큐로 활용 - OUTBOX 테이블
  - 원자성이 보장 된다!
- 이벤트 발행: 폴링 발행기 패턴
  - OUTBOX 테이블을 폴링 하여 미발행 메시지를 조회
- 이벤트 발행: 트랜잭션 로그 테일링 패턴
  - 로그 항목을 보고 발행
  - 사례가 있다. 직접 할일은 많이 없을듯 ..

## 메시징 라이브러리/프레임워크

- 기초 메시징
- 도메인 이벤트 발행
- 커맨드/응답 메시징

# 비동기 메시징으로 가용성 개선
