# 6. 비즈니스 로직 개발: 이벤트 소싱

- 혹시라도 이벤트 발행 로직이 오류를 양산하는 공장이 되지 않을까? 하는 걱정
  - 개발자가 실수로 이벤트 발행 로직을 빠뜨려도 비즈니스 로직은 그냥 흘러간다. 이것이 버그의 원천이 될 수 있다.
- 이벤트 소싱은 모든 변경 이력을 애그리거트에 고스란히 보존한다.

# 6.1 이벤트 소싱 응용 비즈니스 로직 개발

- 이벤트 소싱은 비즈니스 로직을 구성하고 애그리거트를 저장하는 또 다른 방법
- 애그리거트를 일련의 이벤트 형태로 저장 한다.
- 애플리케이션은 이벤트를 재연하여 애그리거트의 현재 상태를 재생성 한다.

## 6.1.1 기존 영속화의 문제점

- (241p 그림 6-1) 클래스 인스턴스는 테이블 각 로우에 매핑 된다.
  - 객체-관계 임피던스 부정합
  - 애그리거트 이력이 없다.
  - 감사 로깅 구현하기가 번거롭고 에러가 잘 난다.
  - 이벤트 발행 로직이 비즈니스 로직에 추가된다.

## 6.1.2 이벤트 소싱 개요

- 이벤트 위주로 비즈니스 로직을 구현하고, 애그리거트로 DB에 일련의 이벤트로 저장하는 기법
- (244p 그림 6-2)
- 이벤트를 테이블에 쌓고 애그리거트를 로드 할 때
  - 애그리거트의 이벤트를 로드함.
  - 기본 생성자를 호출하여 애그리거트 인스턴스를 생성
  - 이벤트를 하나씩 순회하며 apply()를 호출
- fold or reduce 작업이다.
- 도메인 이벤트는 애그리거트의 변경을 구독자에게 알리는 장치로, 최소한의 필수 데이터만 넣거나 컨슈머에 유용한 데이터까지 포함시켜 강화할 수 있다. (엔벨롭객체?)
- (246 그림 6-3) 이해 하자
- 애그리거트 메서드의 관심사는 오직 이벤트
  - 요청 커맨드를 매개변수로 받아 상태를 어떻게 변경할지 결정 한다. process
  - 이벤트를 매개변수로 받아 애그리거트를 업데이트 한다. apply

## 6.1.3 동시 업데이트: 낙관적 잠금

- 기존 영속화 메커니즘은 대개 한 트랜잭션의 변경을 덮어 쓰지 못하게 낙관적 잠금을 하여 처리 한다.

## 6.1.4 이벤트 소싱과 이벤트 발행

- 이벤트를 저장하는것은 원자적인 작업이다. 어떻게 저장된 모든 이벤트를 관심있는 컨슈머에게 전달 할까?!
  - 이벤트 발행: 폴링
    - 트랜잭션이 이벤트 발행 순서와 다르게 커밋할 수 있다는 문제가 있다. ⇒ 발행 여부를 추적하는 컬럼 추가
  - 이벤트 발행: 트랜잭션 로그 테일링
    - 3장에서함, 이벤추에이트 로컬도 이 방식으로 다룬다. 왜 자꾸 이벤추에이트 들먹임

## 6.1.5 스냅샷으로 성능 개선

- Account처럼 애그리거트 수명이 긴 애그리거트는 이벤트 수가 꽤 많아서 일일이 로드/폴드 하기가 만만치 않다.
  - 주기적으로 스냅샷을 떠서 최근에 뜬 스냅샷과 그 이후 발생한 이벤트만 가져와 복원

## 6.1.6 멱등한 메시지 처리

- 서비스는 대부분 다른 애플리케이션 또는 서비스로부터 받은 메시지를 소비한다.
- 그런데 메시지 브로커가 동일한 메시지를 여러 번 전송할 가능성이 있으므로 메시지 컨슈머는 멱등하게 개발 해야 한다.
- RDBMS, NoSQL 이벤트 저장소 사용시

## 6.1.7 도메인 이벤트 발전시키기

- 이벤트 구조가 변경됨에 따라 새로운 문제가 생기게 마련이다.
- 이벤트는 잠재적으로 여러 버전의 이벤트를 처리해야 한다.
- 이벤트 소싱에 기반한 애플리케이션의 스키마
  - 하나 이상의 애그리거트로 구성된다.
  - 각 애그리거트가 발생시키는 이벤트를 정의한다.
  - 이벤트 구조를 정의한다.
- 이벤트에 필드를 추가하거나 그런건 괜찮지만, 이벤트 명이 바뀐다던지 하면 쉽지 않다.
- 업캐스팅을 통한 스키마 변화 관리
  - 이벤트 소싱 프레임웤이 해준다. 설명 끝 . . .?

## 6.1.8 이벤트 소싱의 장점

- 도메인 이벤트를 확실하게 발행한다.
- 애그리거트 이력이 보존된다.
- O/R 임피던스 불일치 문제를 대부분 방지할 수 있다.
- 개발자에게 타임 머신을 제공한다.

## 6.1.9 이벤트 소싱의 단점

- 새로운 프로그래밍 모델을 배우는 데 시간이 걸린다.
- 메시징 기반 애플리케이션은 복잡하다.
- 이벤트를 개량하기가 까다롭다.
- 데이터를 삭제하기가 어렵다.
- 이벤트 저장소를 쿼리하기가 만만찮다.

# 6.2 이벤트 저장소 구현

- 이벤트 저장소는 db와 메시지 브로커를 합한 것
- 애그리거트의 이벤트를 기본키로 삽입/조회하는 API가 있어 마치 DB처럼 움직이면서, 이벤트를 구독하는 API도 잇어서 메시지 브로커처럼 동작하기도 한다.
- 대충 이벤추에이트 설명
  - 아니 대충 이벤트 소싱이란 기법만 알면 됐고 저장소가 어떻게 구현되어있는지는 진짜 필요해서 쓸 때 찾아보면 될듯...

# 6.3 사가와 이벤트 소싱을 접목

- 이벤트 소싱에서는 코레오그래피 사가를 쉽게 이용할 수 있다. 참여자는 자신의 애그리거트가 발생시킨 도메인 이벤트를 교환하고, 각 참여자의 애그리거트는 커맨드를 처리하고 새로운 이벤트를 발생
- 사가의 각 단계는 원자적으로 수행되어야 하는 액션들로 구성
  - 사가 생성: createOrder는 Order 애그리거트와 createOrderSaga 생성
  - 사가 오케스트레이션: 원자적으로 응답을 소비하고, 자신의 상태를 업데이트한 후 커맨드 메시지 전송
  - 사가 참여자: 주방 서비스, 주문 서비스 등 원자적으로 소비하고, 중복 메시지를 솎아내고, 응답 메시지 전송
- 이벤트 소싱은 속성상 이벤트가 모든 것을 주도하므로 코레오그래피 사가를 아주 쉽게 구현할 수 있다.
  - 애그리거트가 업데이트되면 사가가 이벤트를 발생시키고, 이벤트 핸들러는 해당 이벤트를 소비한 후 애그리거트를 업데이트 한다.
- (275p. 그림 6-11)
- 이벤트 소싱 기반의 사가 참여자 구현
  - 커맨드 메시지를 멱등하게 처리
  - 응답 메시지를 원자적으로 전송
- 사가 오케스트레이터 구현: 이벤트 소싱
  - 이벤트 소싱으로 사가 오케스트레이터 저장
  - 커맨드 메시지를 확실라게 전송 (transactional메시징 방식도 있지만 전송할 커맨드를 나타낸 SagaCommmandEvent 자체를 저장)
  - 응답을 꼭 한 번만 처리
